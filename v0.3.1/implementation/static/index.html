<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Learn Susceptances · ContGridModML</title><meta name="title" content="Learn Susceptances · ContGridModML"/><meta property="og:title" content="Learn Susceptances · ContGridModML"/><meta property="twitter:title" content="Learn Susceptances · ContGridModML"/><meta name="description" content="Documentation for ContGridModML."/><meta property="og:description" content="Documentation for ContGridModML."/><meta property="twitter:description" content="Documentation for ContGridModML."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ContGridModML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Implementation</span><ul><li><a class="tocitem" href="../finite/">Finite Element Method</a></li><li><a class="tocitem" href="../general/">General Implementation</a></li><li class="is-active"><a class="tocitem" href>Learn Susceptances</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/public/">Public</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Internal</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/internal/dynamic/">Dynamic.jl</a></li><li><a class="tocitem" href="../../api/internal/static/">Static.jl</a></li><li><a class="tocitem" href="../../api/internal/tools/">Tools.jl</a></li><li><a class="tocitem" href="../../api/internal/mesh/">Mesh.jl</a></li><li><a class="tocitem" href="../../api/internal/init/">Initl.jl</a></li><li><a class="tocitem" href="../../api/internal/disc_dynamics/">Disc_dynamics.jl</a></li><li><a class="tocitem" href="../../api/internal/cont_dynamics/">Cont_dynamics.jl</a></li><li><a class="tocitem" href="../../api/internal/plot/">Plot.jl</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implementation</a></li><li class="is-active"><a href>Learn Susceptances</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Learn Susceptances</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/julianfritzsch/ContGridModML.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/julianfritzsch/ContGridModML.jl/blob/main/docs/src/implementation/static.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation-of-the-Susceptance-Learning"><a class="docs-heading-anchor" href="#Implementation-of-the-Susceptance-Learning">Implementation of the Susceptance Learning</a><a id="Implementation-of-the-Susceptance-Learning-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-the-Susceptance-Learning" title="Permalink"></a></h1><p>The line susceptance are learned by comparing the static solution obtained from the continuous model with the solutions obtained from the power flow equations for the discrete case. Learning is done by <a href="../../api/public/#ContGridModML.learn_susceptances"><code>learn_susceptances</code></a>. The process consists of the following steps</p><ol><li><a href="#Load-the-discrete-models">Load the discrete models</a></li><li><a href="#Create-all-the-necessary-matrices">Create all the necessary matrices</a></li><li><a href="#Create-all-projectors">Create all projectors</a></li><li><a href="#Create-the-force-vectors">Create the force vectors</a></li><li><a href="#Assemble-the-training-and-test-data-sets">Assemble the training and test data sets</a></li><li><a href="#Do-the-learning">Do the learning</a></li><li><a href="#Calculate-the-predictions">Calculate the predictions</a></li><li><a href="#Calculate-the-loss-values-for-the-predictions">Calculate the loss values for the predictions</a></li></ol><h3 id="Load-the-discrete-models"><a class="docs-heading-anchor" href="#Load-the-discrete-models">Load the discrete models</a><a id="Load-the-discrete-models-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-discrete-models" title="Permalink"></a></h3><p>First the grid is loaded from a GMSH file. After this we load all the discrete models used for the training and the test. This is all done as described in <a href="../general/#Creating-Models">Creating Models</a>. Each single discrete model corresponds to one dispatch.</p><p>See: <a href="../../api/internal/static/#ContGridModML.discrete_models-Tuple{String, String, Real}"><code>ContGridModML.discrete_models</code></a></p><h3 id="Create-all-the-necessary-matrices"><a class="docs-heading-anchor" href="#Create-all-the-necessary-matrices">Create all the necessary matrices</a><a id="Create-all-the-necessary-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Create-all-the-necessary-matrices" title="Permalink"></a></h3><h4 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h4><p>The matrices created are motivated as follows. We begin with the stiffness matrix. Recall that it is given by (dropping the transformation of the gradients as this taken care of by <code>Ferrite</code>)</p><p class="math-container">\[\mathbf{K}_{ij} = \sum_E\sum_k\omega_k \nabla\phi_i(\mathbf{q_k})
\begin{bmatrix}b_x(\mathbf{q}_k) &amp; 0 \\ 0 &amp; b_y(\mathbf{q}_k)\end{bmatrix}
\nabla\phi_j(\mathbf{q}_k)\det(J),\]</p><p>Note that the sum over <span>$k$</span> can be written as</p><p class="math-container">\[ \begin{bmatrix}\nabla\phi_i(\mathbf{q_1})\\\nabla\phi_i(\mathbf{q_2})\\\vdots\end{bmatrix}^\top
\begin{bmatrix}b_x(\mathbf{q}_1) &amp; 0 &amp; 0 &amp; 0 &amp; \cdots\\ 0 &amp; b_y(\mathbf{q}_1) &amp; 0 &amp; 0 &amp; \cdots\\0 &amp; 0 &amp; b_x(\mathbf{q}_2) &amp; 0 &amp; \cdots \\ 0 &amp; 0 &amp; 0 &amp; b_y(\mathbf{q}_2) &amp; \cdots\\\vdots&amp;\vdots&amp;\vdots&amp;\vdots&amp;\ddots\end{bmatrix}
\begin{bmatrix}\nabla\phi_j(\mathbf{q_1})\\\nabla\phi_j(\mathbf{q_2})\\\vdots\end{bmatrix}\]</p><p>To eliminate the sum over <span>$E$</span>, we can pull the determinant and quadrature weight into the gradient and label all quadrature points continuously. Introducing the matrix <span>$\mathbf{A}$</span> which is made of <span>$1\times2$</span> blocks with</p><p class="math-container">\[\mathbf{A}_{ij} = (\nabla \phi_i(\mathbf{q}_{j}))^\top \sqrt{\omega_j\det(J_{j})},\]</p><p>where <span>$\omega_j$</span> and <span>$J_j$</span> are the weight and determinant that belong to quadrature point <span>$j$</span>. It is obvious that we can write the stiffness matrix as</p><p class="math-container">\[\mathbf{K} = \mathbf{A} \mathrm{diag}(b_x(\mathbf{q}_1), b_y(\mathbf{q}_1), \dots) \mathbf{A}^\top.\]</p><p>Therefore, the first matrix we need to create is <span>$\mathbf{A}$</span>. As we need the values of <span>$b$</span> in the quadrature points, we will collect the coordinates of the quadrature points in the process of creating <span>$\mathbf{A}$</span>. The next matrix we need is related to enforcing the value of the slack bus. This means that at one node the solution to the static problem is fixed at 0. This is achieved by setting the row and column of the stiffness matrix corresponding to that node to zero and adding a 1 on the diagonal for that node. Additionally the corresponding entry of the force vector will be set to zero. The next matrix therefore has only one entry: 1 on the diagonal corresponding to the slack node. Finally, we need to create one more matrix. Similar to the above, we want to write the force vector as</p><p class="math-container">\[\mathbf{f} = \mathbf{A}_f \begin{bmatrix} P(\mathbf{q}_1)\\ P(\mathbf{q}_2) \\ \vdots \end{bmatrix}.\]</p><p>The derivation is very similar to the above and we find</p><p class="math-container">\[\mathbf{A}_{f,ij} = \phi_i(\mathbf{q}_j) \omega_j \det(J_j).\]</p><h4 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h4><p>First the continuous model is loaded as described in <a href="../general/#Creating-Models">Creating Models</a>. We begin by creating allocating the required matrices, getting the number of base functions, and initializing the quadrature point iterators.</p><pre><code class="language-julia hljs">q_coords = zeros(getnquadpoints(model.cellvalues) * size(model.grid.cells, 1), 2)
Af = zeros(ndofs(model.dh₁),
    getnquadpoints(model.cellvalues) * size(model.grid.cells, 1))
Ak = zeros(ndofs(model.dh₁),
    2 * getnquadpoints(model.cellvalues) * size(model.grid.cells, 1))

n_basefuncs = getnbasefunctions(model.cellvalues)
ix_af = 1
ix_ak = 1</code></pre><p>Afterwards we loop over all cells using the <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/dofhandler/#Ferrite.CellIterator"><code>CellIterator</code></a>. For each cell the cell values need to be initialized so the structure contains the correct gradient values. We also get the degrees of freedom that are associated with this cell.</p><pre><code class="language-julia hljs">for (ix, cell) in enumerate(CellIterator(model.dh₁))
    Ferrite.reinit!(model.cellvalues, cell)
    dofs = celldofs(cell)</code></pre><p>Next, we loop over all the quadrature points in the cell. First we get the coordinates of that point and the value of the product of the quadrature weight and the Jacobian determinant at this quadrature point. The coordinates will be saved in the associated matrix.</p><pre><code class="language-julia hljs">    for q_point in 1:getnquadpoints(model.cellvalues)
        x = spatial_coordinate(model.cellvalues, q_point, getcoordinates(cell))
        dΩ = getdetJdV(model.cellvalues, q_point)
        q_coords[ix_af, :] = x</code></pre><p>Next we iterate over the base functions associated with that cell (only base functions associated with this cell have a non-zero contribution in the quadrature points). We can easily obtain the value and its gradient at the quadrature point from Ferrite and fill the matrix as described in the motivation section.</p><pre><code class="language-julia hljs">        for i in 1:n_basefuncs
            φᵢ = shape_value(model.cellvalues, q_point, i)
            ∇φᵢ = shape_gradient(model.cellvalues, q_point, i)
            Af[dofs[i], ix_af] = φᵢ * dΩ
            Ak[dofs[i], ix_ak:ix_ak+1] = ∇φᵢ * sqrt(dΩ)
        end</code></pre><p>Finally, we need to increase the quadrature point iterators.</p><pre><code class="language-julia hljs">        ix_af += 1
        ix_ak += 2
    end
end</code></pre><p>The last thing left to do is to enforce the slack node. The correct degree of freedom can be straightforwardly obtained from the <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/boundary_conditions/#Ferrite.ConstraintHandler"><code>ConstraintHandler</code></a>.</p><pre><code class="language-julia hljs">Ak[model.ch.prescribed_dofs, :] .= 0.0
Af[model.ch.prescribed_dofs, :] .= 0.0
dim = zeros(ndofs(model.dh₁), ndofs(model.dh₁))
dim[model.ch.prescribed_dofs, model.ch.prescribed_dofs] .= 1</code></pre><p>See: <a href="../../api/internal/static/#ContGridModML.assemble_matrices_static-Tuple{ContGridModML.ContModel}"><code>ContGridModML.assemble_matrices_static</code></a></p><h3 id="Create-all-projectors"><a class="docs-heading-anchor" href="#Create-all-projectors">Create all projectors</a><a id="Create-all-projectors-1"></a><a class="docs-heading-anchor-permalink" href="#Create-all-projectors" title="Permalink"></a></h3><h4 id="Motivation-2"><a class="docs-heading-anchor" href="#Motivation-2">Motivation</a><a class="docs-heading-anchor-permalink" href="#Motivation-2" title="Permalink"></a></h4><p>While <a href="https://ferrite-fem.github.io/Ferrite.jl/stable"><code>Ferrite</code></a> has the option to obtain values at arbitrary point given a <code>DofHandler</code> and the nodal values doing this at every step of the training is time consuming. Additionally, this is not compatible with the automatic differentiation of <code>Flux</code>. However, we can easily turn the interpolation into an easy matrix multiplication.</p><p>Let&#39;s revisit the way that we can obtain values at arbitrary points using the finite element method. In general a field  <span>$u(\mathbf{r})$</span> is expanded as follows</p><p class="math-container">\[u(\mathbf{r}) = \sum_i \phi_i(\mathbf{r}) \hat{u}_i,\]</p><p>where <span>$\phi_i$</span> are the base functions and <span>$\hat{u}_i$</span> are the nodal values. As the position of the quadrature points and the discrete values in the grid does not change we can simply calculate <span>$\phi(\mathbf{r})$</span> for all these points and then multiply them by the nodal values. As an example take the values of <span>$b_x$</span> and <span>$b_y$</span> in the first quadrature points they can be obtained by</p><p class="math-container">\[\begin{bmatrix}b_x(\mathbf{q}_1) \\ b_y(\mathbf{q}_2)\end{bmatrix} = 
\begin{bmatrix}\phi_1(\mathbf{q}_1) &amp; 0 &amp; \phi_2(\mathbf{q}_1) &amp; 0 &amp; \dots \\ 0 &amp; \phi_1(\mathbf{q}_1) &amp; 0 &amp; \phi_2(\mathbf{q}_1) &amp; \dots\end{bmatrix}
\begin{bmatrix}
\widehat{b_x}_{1} \\ \widehat{b_y}_{1} \\ \vdots
\end{bmatrix}\]</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In general we wouldn&#39;t need to project values of <span>$P(\mathbf{r})$</span> but rather use the actual values. However, the distribution has been obtained through the heat equation diffusion and therefore we only have the values on the nodes. The <code>DofHandler</code> is the same as the one used for the steady state solution.</p></div></div><h4 id="Implementation-2"><a class="docs-heading-anchor" href="#Implementation-2">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-2" title="Permalink"></a></h4><p>We need to create three projection matrices: for the buses in the discrete model, for the sucsceptances onto the quadrature points, and for the power onto the quadrature points. To demonstrate the creation of these matrices with <code>Ferrite</code>, we show the assembly of the projection matrix for the buses of the discrete model.</p><p>We start by allocating the memory for the matrix, getting the function interpolations used, and obtaining the coordinates of the grid nodes.</p><pre><code class="language-julia hljs">func_interpolations = Ferrite.get_func_interpolations(model.dh₁, :u)
grid_coords = [node.x for node in model.grid.nodes]
n_base_funcs = getnbasefunctions(model.cellvalues)
θ_proj = zeros(size(dm.th, 1), ndofs(model.dh₁))</code></pre><p>Next, we loop over all the coordinates in the discrete model. Using the <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/reference/export/#Ferrite.PointEvalHandler"><code>PointEvalHandler</code></a> allows us to find the cell in which the coordinate is located. Additionally, it yields the position of the coordinate within the cell in reference coordinates. In case the coordinate is not inside the grid (for example, some buses are located on islands), we choose the closest node of the grid.</p><pre><code class="language-julia hljs">for (i, point) in enumerate(eachrow(dm.coord))
    ph = PointEvalHandler(model.grid, [Ferrite.Vec(point...)], warn = :false)
    if ph.cells[1] === nothing
        min_ix = argmin([norm(coord .- Ferrite.Vec(dm.coord[i, :]...))
                         for coord in grid_coords])
        ph = PointEvalHandler(model.grid, [grid_coords[min_ix]])
    end</code></pre><p>Next, we obtain the values of the base functions at this point, get the degrees of freedom, and assemble the matrix.</p><pre><code class="language-julia hljs">    pv = Ferrite.PointScalarValuesInternal(ph.local_coords[1], func_interpolations[1])
    cell_dofs = Vector{Int}(undef, ndofs_per_cell(model.dh₁, ph.cells[1]))
    Ferrite.celldofs!(cell_dofs, model.dh₁, ph.cells[1])
    for j in 1:n_base_funcs
        θ_proj[i, cell_dofs[j]] = pv.N[j]
    end
end</code></pre><p>The assembly of the quadrature point projectors works analogously. We do not need to check whether the points are inside the grid. The pattern of the projector for the susceptances is obtained as follows</p><pre><code class="language-julia hljs">q_proj_b[2 * i - 1, 2 * cell_dofs[j] - 1] = pv.N[j]
q_proj_b[2 * i, 2 * cell_dofs[j]] = pv.N[j]</code></pre><p>See: <a href="../../api/internal/static/#ContGridModML.projectors_static-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel}"><code>ContGridModML.projectors_static</code></a></p><h3 id="Create-the-force-vectors"><a class="docs-heading-anchor" href="#Create-the-force-vectors">Create the force vectors</a><a id="Create-the-force-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Create-the-force-vectors" title="Permalink"></a></h3><p>The creation of the force vectors is quite simple. We update the model using the discrete models so that it contains the correct power data. Then we use the projection matrix to obtain the values in the quadrature points and finally use the <code>Af</code> matrix to contain the force vector.</p><pre><code class="language-julia hljs">for i in 1:size(training, 1)
    update_model!(model, :p, training[i], tf, κ = κ, σ = σ)
    f_train[:, i] = Af * q_proj * model.p_nodal
end</code></pre><p>See: <a href="../../api/internal/static/#ContGridModML.assemble_f_static-Tuple{ContGridModML.ContModel, Vector{ContGridModML.DiscModel}, SparseArrays.SparseMatrixCSC}"><code>ContGridModML.assemble_f_static</code></a></p><h3 id="Assemble-the-training-and-test-data-sets"><a class="docs-heading-anchor" href="#Assemble-the-training-and-test-data-sets">Assemble the training and test data sets</a><a id="Assemble-the-training-and-test-data-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble-the-training-and-test-data-sets" title="Permalink"></a></h3><p>We simply create a matrix that contains all the ground truth data, <em>i.e.</em>, all the steady state angles of the discrete models. This allows us to train on all the data sets simultaneously.</p><pre><code class="language-julia hljs">for i in 1:size(training, 1)
    t_train[:, i] = training[i].th
end</code></pre><p>See: <a href="../../api/internal/static/#ContGridModML.assemble_disc_theta-Tuple{Vector{ContGridModML.DiscModel}}"><code>ContGridModML.assemble_disc_theta</code></a></p><h3 id="Do-the-learning"><a class="docs-heading-anchor" href="#Do-the-learning">Do the learning</a><a id="Do-the-learning-1"></a><a class="docs-heading-anchor-permalink" href="#Do-the-learning" title="Permalink"></a></h3><p>Doing the actual learning is straightforward. We use <code>Flux</code> to calculate the gradient and update the parameters. At each step we assemble the stiffness matrix. Then we obtain the nodal values of the steady state solution by solving the linear system <span>$\mathbf{K}\mathbf{\theta}_0 = \mathbf{f}$</span> and project them onto discrete bus locations. The loss function is given by the Huber loss. An epoch looks like</p><pre><code class="language-julia hljs">for batch in 1:n_batches
    local loss
    gs = Flux.gradient(param) do
        btemp = max.(b, bmin)
        K = A * sparse(1:n_q, 1:n_q, q_proj * btemp) * A&#39; + dim
        θ = proj * (K \ f_train[:,
            shuffled_ix[((batch - 1) * batch_size + 1):(batch * batch_size)]])
        loss = Flux.huber_loss(θ,
            t_train[:,
                shuffled_ix[((batch - 1) * batch_size + 1):(batch * batch_size)]],
            delta = δ)
    end
    losses[e, batch] = loss
    if (mod(e, 50) == 0 &amp;&amp; batch == 3)
        println(string(e) * &quot;, &quot; * string(mean(losses[e, :])))
    end
    Flux.update!(opt, param, gs)
end</code></pre><h3 id="Calculate-the-predictions"><a class="docs-heading-anchor" href="#Calculate-the-predictions">Calculate the predictions</a><a id="Calculate-the-predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-the-predictions" title="Permalink"></a></h3><p>The predictions are calculated like shown in the previous section.</p><p>See: <a href="../../api/internal/static/#ContGridModML.prediction-Union{Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix, Matrix{T}, Matrix{T}, SparseArrays.AbstractSparseMatrix}} where T&lt;:Real"><code>ContGridModML.prediction</code></a></p><h3 id="Calculate-the-loss-values-for-the-predictions"><a class="docs-heading-anchor" href="#Calculate-the-loss-values-for-the-predictions">Calculate the loss values for the predictions</a><a id="Calculate-the-loss-values-for-the-predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Calculate-the-loss-values-for-the-predictions" title="Permalink"></a></h3><p>The Huber loss for all predictions is calculated.</p><pre><code class="language-julia hljs">train_losses = vcat(Flux.huber_loss(train_pred,
    t_train,
    delta = δ,
    agg = x -&gt; mean(x, dims = 1))...)</code></pre><p>See: <a href="../../api/internal/static/#ContGridModML.get_losses-Tuple{Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}, Matrix{&lt;:Real}}"><code>ContGridModML.get_losses</code></a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../general/">« General Implementation</a><a class="docs-footer-nextpage" href="../../api/public/">Public »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 16 February 2024 09:35">Friday 16 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
