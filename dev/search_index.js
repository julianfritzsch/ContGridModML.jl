var documenterSearchIndex = {"docs":
[{"location":"implementation/general/#Notes-on-the-General-Implementation","page":"General Implementation","title":"Notes on the General Implementation","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"In the following there are some general notes on the implementation of the continuous model using Ferrite and ContGridMod.","category":"page"},{"location":"implementation/general/#Ferrite","page":"General Implementation","title":"Ferrite","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"In general Ferrite takes care of most things when it comes to keeping track of the degrees of freedom (nodal values) as well as calculating all the needed values of the base functions and its gradients. Additionally, it makes assembling the mass and stiffness matrix, and the force vector easy and allows finding the cells in which arbitrary points are located. The central element is the DofHandler. It keeps track of the different fields (e.g. theta and omega), contains the grid, and the order of the degrees of freedom.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"danger: Danger\nIn general the degrees of freedom do NOT have the same order as the nodes of the grid. Ferrite loops over the cells in the grid and adds the degrees of freedom in the order it encounters them. For example if the first cell is made of nodes 40, 45, and 50, they will correspond to the degrees of freedom 1, 2, and 3. This is very important to keep in mind when trying to create matrices or to map result vectors onto the grid.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"Another important structure is the CellValues. It contains the values of the base functions in the quadrature points as well as their gradients. The gradient values are automatically transformed to their proper values from their reference values. It also contains the product of the determinant of the Jacobian with the quadrature weight.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"The final important structure is the ContraintHandler. It allows us to enfoce Dirichlet boundary conditions whithout having to care about the degree of freedom ordering. It is used to enforce the slack bus and to create the initial condition vector for the dynamic simulations.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"To learn more about how Ferrite can be used to assemble the different matrices, check out the Documentation.","category":"page"},{"location":"implementation/general/#ContGridMod","page":"General Implementation","title":"ContGridMod","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"ContGridMod offers data structures for continious and discrete models as well as some utilities. The discrete model is used for the ground truth model. Its dyanmics are governed by","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"beginalign*\nm_i ddottheta_i + d_i dottheta_i = P_i - sum_j b_ijsin(theta_i - theta_j) quadtextfor  i in textgenerator\nd_i dottheta_i = P_i - sum_j b_ijsin(theta_i - theta_j)quadtextfor  i in textload \nendalign*","category":"page"},{"location":"implementation/general/#Structures","page":"General Implementation","title":"Structures","text":"","category":"section"},{"location":"implementation/general/#Discrete-Model","page":"General Implementation","title":"Discrete Model","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"The DiscModel struct provides the following fields:","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"m_gen inertia of each generator\nd_gen damping of each generator\nid_gen IDs of each generator\nid_slack ID of the slack bus\ncoord the coordinates of each bus. They are ordered as (longitude, latitude). The coordinates have been transformed using an Albers Projection and afterwards scaled   by the same factor as the continuous grid such that the longest dimension has length 1.\nd_load damping of each load buses\nid_line matrix containing the lines. They are sorted as (start, end)\nb line suscepetances\np_load consumption of each node\nth steady state solution\np_gen power generation of each generator. If the p_gen = 0. The generator is inactive.\nmax_gen maximum generation of each generator\nNbus number of buses\nNgen number of generators\nNline number of lines","category":"page"},{"location":"implementation/general/#Continuous-Model","page":"General Implementation","title":"Continuous Model","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"The ContModel struct provides the following fields:","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"grid GMSH grid of the continuous model\ndh₁ DofHandler containing one field :u. Used for the stable solution and to obtain field values.\ndh₂ DofHandler containing two fields :θ and :ω. Used for the dynamical simulations.\ncellvalues CellValues object for the two DofHandlers\narea area of the grid used for normalization\nm_nodal nodal values for the inertia\nd_nodal nodal values for the damping\np_nodal nodal values for the power\nbx_nodal nodal values for the x component of the susceptance\nby_nodal nodal values for the y component of the susceptance\nθ₀_nodal nodal values for the steady state solution\nfault_nodal nodal values for the power fault\nm function returning inertia at point x\nd function returning damping at point x\np function returning power at point x\nbx function returning x component of the susceptance at point x\nby function returning y component of the susceptance at point x\nθ₀ function returning steady state solution at point x\nfault function returning the power fault at point x\nch ConstraintHandler to enforce the slack bus","category":"page"},{"location":"implementation/general/#Creating-Models","page":"General Implementation","title":"Creating Models","text":"","category":"section"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"To create the models from scratch, we first need to load a grid. The grid can be created from a polygon. The corners of the polygon need to be placed in a JSON file with the following structure","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"{\n    \"border\": [[x0, y0],\n                [x1, y1],\n                ...\n              ]\n}","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"The file is then loaded, the Albers projection applied, rescaled, and turned into a GMSH grid as follows (dx is the mesh element size)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> using ContGridMod\njulia> grid, scale_factor = get_grid(file_name, dx)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"Alternatively, one can also directly load an existing GMSH file with the same command.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"Next the discrete model can be loaded from a HDF5 file. The data in the HDF5 file needs to contain the grid in the Matpower Data format with the additional data fields defined in the original PanTaGruEl model. If you want to know more you can investigate the included scenarios in the data/ml folder of this repository.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> dm = load_discrete_model(file_name, scale_factor)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"Finally, the continuous model can be created using the grid and the discrete model. The parameters are distributed using a heat equation diffusion.","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> cm = get_params(grid, 0.05, dm, κ=0.02, bfactor=50000.0, σ=0.01, bmin=1)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"Faults in the discrete model can be simulated by","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> sol = disc_dynamics(dm, t0, tf, dP, faultid=id)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"For faults in the continuous model we first need to calculate the steady state solution, then create the fault, and finally run the simulation","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> stable_sol!(cm)\njulia> add_local_disturbance!(cm, coords, dP, σ)\njulia> sol = perform_dyn_sim(cm, t0, tf)","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"The models can easily be saved as HDF5 file and loaded","category":"page"},{"location":"implementation/general/","page":"General Implementation","title":"General Implementation","text":"julia> save_model(file_name, model)\njulia> model = load_model(file_name)","category":"page"},{"location":"api/internal/disc_dynamics/#Disc_dynamics.jl","page":"Disc_dynamics.jl","title":"Disc_dynamics.jl","text":"","category":"section"},{"location":"api/internal/disc_dynamics/#Functions","page":"Disc_dynamics.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/disc_dynamics/","page":"Disc_dynamics.jl","title":"Disc_dynamics.jl","text":"Modules = [ContGridModML]\nPages = [\"disc_dynamics.jl\"]","category":"page"},{"location":"api/internal/disc_dynamics/#ContGridModML.NRsolver-Tuple{SparseArrays.SparseMatrixCSC{<:Complex, <:Int64}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Real}, Vector{<:Int64}, Int64}","page":"Disc_dynamics.jl","title":"ContGridModML.NRsolver","text":"NRsolver(\n    Ybus::SparseArrays.SparseMatrixCSC{<:Complex, <:Int64},\n    V::Vector{<:Real},\n    theta::Vector{<:Real},\n    p::Vector{<:Real},\n    q::Vector{<:Real},\n    idpq::Vector{<:Int64},\n    id_slack::Int64;\n    tol,\n    maxiter\n) -> Tuple{Vector{<:Real}, Vector{<:Real}, Int64}\n\n\nUse the Newton Raphson method to solve the powerflow equations.This method is adapted from its version on the Pantagruel repository (https://doi.org/10.5281/zenodo.2642175). For information on solving the power flow equations with Newton-Raphson, see,  for instance, V. Vittal and A. Bergen, Power systems analysis, Prentice Hall, 1999. \n\n\n\n\n\n","category":"method"},{"location":"api/internal/disc_dynamics/#ContGridModML.disc_dynamics-Tuple{ContGridModML.DiscModel, Real, Real, Union{Real, Vector{<:Real}}, Int64}","page":"Disc_dynamics.jl","title":"ContGridModML.disc_dynamics","text":"disc_dynamics(\n    dm::ContGridModML.DiscModel,\n    tstart::Real,\n    tend::Real,\n    delta_p::Union{Real, Vector{<:Real}},\n    faultid::Int64;\n    dt,\n    tol,\n    maxiter,\n    dmin,\n    alg,\n    solve_kwargs\n) -> SciMLBase.ODESolution\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#Static.jl","page":"Static.jl","title":"Static.jl","text":"","category":"section"},{"location":"api/internal/static/","page":"Static.jl","title":"Static.jl","text":"Description of internally used functions for the learning of the static parameters.","category":"page"},{"location":"api/internal/static/#Contents","page":"Static.jl","title":"Contents","text":"","category":"section"},{"location":"api/internal/static/","page":"Static.jl","title":"Static.jl","text":"Pages = [\"static.md\"]\nDepth = 2:2","category":"page"},{"location":"api/internal/static/#Index","page":"Static.jl","title":"Index","text":"","category":"section"},{"location":"api/internal/static/","page":"Static.jl","title":"Static.jl","text":"Pages = [\"static.md\"]","category":"page"},{"location":"api/internal/static/#Functions","page":"Static.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/static/","page":"Static.jl","title":"Static.jl","text":"Modules = [ContGridModML]\nPages = [\"static.jl\"]","category":"page"},{"location":"api/internal/static/#ContGridModML._learn_susceptances-Union{Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix, SparseArrays.AbstractSparseMatrix, SparseArrays.AbstractSparseMatrix, SparseArrays.AbstractSparseMatrix, Matrix{T}, Matrix{T}, Vector{T}, Matrix{T}, Vector{Int64}, Integer, Int64}} where T<:Real","page":"Static.jl","title":"ContGridModML._learn_susceptances","text":"_learn_susceptances(\n    A::SparseArrays.AbstractSparseMatrix,\n    Islack::SparseArrays.AbstractSparseMatrix,\n    q_proj::SparseArrays.AbstractSparseMatrix,\n    disc_proj::SparseArrays.AbstractSparseMatrix,\n    f_train::Array{T<:Real, 2},\n    th_train::Array{T<:Real, 2},\n    p::Array{T<:Real, 1},\n    eve::Array{T<:Real, 2},\n    comp_ix::Vector{Int64},\n    n_epoch::Integer,\n    n_batch::Int64;\n    opt,\n    bmin,\n    rng,\n    δ\n) -> Tuple{Any, Matrix{T} where T<:Real}\n\n\nDo the actual learning of the parameters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.assemble_disc_theta-Tuple{Vector{ContGridModML.DiscModel}}","page":"Static.jl","title":"ContGridModML.assemble_disc_theta","text":"assemble_disc_theta(\n    dataset::Vector{ContGridModML.DiscModel}\n) -> Matrix{<:Real}\n\n\nAssemble all the ground truth data into one matrix for the training and one for the test sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.assemble_f_static-Tuple{ContGridModML.ContModel, Vector{ContGridModML.DiscModel}, SparseArrays.SparseMatrixCSC}","page":"Static.jl","title":"ContGridModML.assemble_f_static","text":"assemble_f_static(\n    model::ContGridModML.ContModel,\n    dataset::Vector{ContGridModML.DiscModel},\n    Af::SparseArrays.SparseMatrixCSC\n) -> Matrix{Float64}\n\n\nAssemble the force vectors for the static solutions.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.assemble_matrices_static-Tuple{ContGridModML.ContModel}","page":"Static.jl","title":"ContGridModML.assemble_matrices_static","text":"assemble_matrices_static(\n    model::ContGridModML.ContModel\n) -> Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\n\nCreate all the necessary finite element matrices from a given model.\n\nThe returned matrices are\n\nAf the matrix needed to create the force vector as f = Af * p_quad\nAk the matrix needed to create the stiffness matrix as K = A * b_quad * A'. The   susceptances need to be ordered as   b_x(mathbfq_1) b_y(mathbfq_1) b_x(mathbfq_2)dots\ndim matrix with single entry for the slack bus to ensure well-posedness of the system   of linear equations\nq_coords Coordinates of the quadrature points in the same order as stored in   the DoF-handler\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.check_slack-Tuple{Vector{ContGridModML.DiscModel}}","page":"Static.jl","title":"ContGridModML.check_slack","text":"check_slack(\n    dataset::Vector{ContGridModML.DiscModel}\n) -> Bool\n\n\nCheck if all the slack buses in the training and test data sets are the same.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.discrete_models-Tuple{String, String, Real}","page":"Static.jl","title":"ContGridModML.discrete_models","text":"discrete_models(\n    train_folder::String,\n    test_folder::String,\n    scale_factor::Real\n) -> Tuple{Vector{ContGridModML.DiscModel}, Vector{ContGridModML.DiscModel}}\n\n\nLoad all the discrete models for the training and test data sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.get_losses-Tuple{Matrix{<:Real}, Matrix{<:Real}, Matrix{<:Real}, Matrix{<:Real}}","page":"Static.jl","title":"ContGridModML.get_losses","text":"get_losses(\n    train_pred::Matrix{<:Real},\n    test_pred::Matrix{<:Real},\n    t_train::Matrix{<:Real},\n    t_test::Matrix{<:Real};\n    δ\n) -> Tuple{Vector{T} where T<:Real, Vector{T} where T<:Real}\n\n\nObtain the loss values for the training and test data sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.learn_susceptances-Tuple{}","page":"Static.jl","title":"ContGridModML.learn_susceptances","text":"learn_susceptances(\n;\n    train_folder,\n    test_folder,\n    mesh_fn,\n    n_epoch,\n    n_batch,\n    n_modes,\n    n_coeffs,\n    comp_ix,\n    bx_init,\n    by_init,\n    rng,\n    opt,\n    bmin,\n    δ\n) -> ContGridModML.StaticSol{Float64}\n\n\nLearn the line susceptances.\n\nThe parameters are learned by calculating the stable solution for multiple dispatches and comparing them to the results from the discrete model. The comparison points are obtained by using the liear approximation provided by the finite element method.\n\nArguments\n\ntrain_fn::String = MODULE_FOLDER * \"/data/ml/training_\": The names of the files   containing the training scenarios. The files must be labeled train_fn1.h5,   train_fn2.h5, etc.\ntest_fn::String = MODULE_FOLDER * \"/data/ml/test_\": The names of the files   containing the test scenarios. The files must be labeled test.h5, test.h5, etc.\ngrid_fn::String = MODULE_FOLDER * \"/data/panta.msh\": Name of the file containing the mesh\nn_train::Int = 48: Number of training data sets\nn_test::Int = 12: Number of test data sets\nn_epochs::Int = 10000: Number of epochs\nn_batches::Int = 3: Number of batches per epoch\ntf::Real = 0.05: Duration of the heat equation diffusion for the power distribution \nκ::Real = 0.02: Diffusion constant of the heat equation diffusion for the power   distribution\nσ::Real = 0.01: Standard deviation for the initial Gaussian distribution of the   parameters\nrng::AbstractRNG = Xoshiro(): Random number generator used to draw all random numbers\nbmin::Real = 0.1: Minimimum value of the suscpetances\nδ = 0.5: Parameter of the Huber loss function\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.prediction-Union{Tuple{T}, Tuple{SparseArrays.AbstractSparseMatrix, Matrix{T}, Matrix{T}, SparseArrays.AbstractSparseMatrix}} where T<:Real","page":"Static.jl","title":"ContGridModML.prediction","text":"prediction(\n    K::SparseArrays.AbstractSparseMatrix,\n    f_train::Array{T<:Real, 2},\n    f_test::Array{T<:Real, 2},\n    proj::SparseArrays.AbstractSparseMatrix\n) -> Tuple{Any, Any}\n\n\nObtain the prediction of the stable solution for the training and test data sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/static/#ContGridModML.projectors_static-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel}","page":"Static.jl","title":"ContGridModML.projectors_static","text":"projectors_static(\n    model::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel\n) -> Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\n\nProjectors of nodal values onto the discrete values and the quadrature points.\n\nThe returned matrices are\n\nθ_proj project the nodal values onto the discrete nodes for comparison\nq_proj_b project the susceptances onto the quadrature points. The susceptances need to    be ordered as b_x(mathbfr_1) b_y(mathbfr_1) b_x(mathbfr_2)dots\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#Initl.jl","page":"Initl.jl","title":"Initl.jl","text":"","category":"section"},{"location":"api/internal/init/#Functions","page":"Initl.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/init/","page":"Initl.jl","title":"Initl.jl","text":"Modules = [ContGridModML]\nPages = [\"init.jl\"]","category":"page"},{"location":"api/internal/init/#ContGridModML.distribute_load!-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel}","page":"Initl.jl","title":"ContGridModML.distribute_load!","text":"distribute_load!(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel\n)\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.init_model-Tuple{Ferrite.Grid}","page":"Initl.jl","title":"ContGridModML.init_model","text":"init_model(\n    grid::Ferrite.Grid\n) -> ContGridModML.ContModel{Float64}\n\n\nCreate a continuous model from a discrete model by using a diffusion process to distribute the paramters.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.integrate-Tuple{Ferrite.DofHandler, Ferrite.CellScalarValues, SparseArrays.SparseMatrixCSC, Vector{<:Real}}","page":"Initl.jl","title":"ContGridModML.integrate","text":"integrate(\n    dh::Ferrite.DofHandler,\n    cellvalues::Ferrite.CellScalarValues,\n    q_proj::SparseArrays.SparseMatrixCSC,\n    vals::Vector{<:Real}\n) -> Real\n\n\nIntegrate a function over the whole area of the grid using the finite element method.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.interpolate-Union{Tuple{T}, Tuple{Array{Tensors.Vec{2, T}, 1}, Ferrite.Grid, Ferrite.DofHandler, Vector{<:Real}, Symbol}} where T<:Real","page":"Initl.jl","title":"ContGridModML.interpolate","text":"interpolate(\n    x::Array{Tensors.Tensor{1, 2, T<:Real, 2}, 1},\n    grid::Ferrite.Grid,\n    dh::Ferrite.DofHandler,\n    u::Vector{<:Real},\n    fname::Symbol;\n    off,\n    factor,\n    extrapolate,\n    warn\n) -> Vector{T} where T<:Real\n\n\nInterpolate values from the continues model from a vector of coordinates. If a given coordinate is outside the grid it is replaced by the closed value on the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.interpolate-Union{Tuple{T}, Tuple{Tensors.Vec{2, T}, Ferrite.Grid, Ferrite.DofHandler, Vector{<:Real}, Symbol}} where T<:Real","page":"Initl.jl","title":"ContGridModML.interpolate","text":"interpolate(\n    x::Tensors.Tensor{1, 2, T<:Real, 2},\n    grid::Ferrite.Grid,\n    dh::Ferrite.DofHandler,\n    u::Vector{<:Real},\n    fname::Symbol;\n    off,\n    factor,\n    extrapolate,\n    warn\n) -> Real\n\n\nInterpolate values from the continues model from a  coordinate. If the given coordinate is outside the grid it is replaced by the closed value on the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.set_local_disturbance!-Tuple{ContGridModML.ContModel, Vector{<:Real}, Real}","page":"Initl.jl","title":"ContGridModML.set_local_disturbance!","text":"set_local_disturbance!(\n    cm::ContGridModML.ContModel,\n    coord::Vector{<:Real},\n    dP::Real\n)\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/init/#ContGridModML.set_slack!-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel}","page":"Initl.jl","title":"ContGridModML.set_slack!","text":"set_slack!(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel\n)\n\n\n\n\n\n\n","category":"method"},{"location":"implementation/finite/#Finite-Element-Method","page":"Finite Element Method","title":"Finite Element Method","text":"","category":"section"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"This is a short introduction to the finite element method mostyl based on the documentation of Ferrite.jl with direct applications to the continuous model of power grids. In general, the dynamics of the continuous model are given by the following PDEs","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"m(mathbfr)fracpartial^2 theta(mathbfr t)partial t^2 + d(mathbfr) fracpartialtheta(mathbfr t)partial t = P(mathbfr) + nablaleft(\n        beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta(mathbfr t)right)","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"subject to the Neumann boundary conditions","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbfn left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta(mathbfr t)right) = 0","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"with mathbfr in Omega. The finite element method will be motivated using the static solution to this problem.","category":"page"},{"location":"implementation/finite/#Static-Solution","page":"Finite Element Method","title":"Static Solution","text":"","category":"section"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"To find the static solution, i.e., the solution to the continuous version of the power flow equations, we need to solve the following differential equation","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"nabla left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta_0(mathbfr)right) = -P(mathbfr)","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"subject to the same boundary conditions.","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"We begin by multiplying the equations by an arbitrary test function u(mathbfr) and integrate the resulting equations over the surface on which the PDEs are defined. The left hand side yields","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"beginalign*\n    int u(mathbfr)nabla left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta_0(mathbfr)right) dOmega \n     = int u(mathbfr)left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta_0(mathbfr)right)mathbfnd(partialOmega) - int nabla u(mathbfr)left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta_0(mathbfr)right) d Omega\n     = - int nabla u(mathbfr)left(beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix nabla theta_0(mathbfr)right) d Omega\nendalign*","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"The right hand side simply becomes","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"-int P(mathbfr) u(mathbfr)  dOmega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"After discretization we expand the functions in a set of base functions phi(mathbfr) with the property phi_i(mathbfr_j) = delta_ij, where mathbfr_j is the jth nodal point. The expansions read","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"u(mathbfr) approx sum_ihatu_iphi_i(mathbfr)qquad theta_0(mathbfr) approx sum_ihattheta_iphi_i(mathbfr)","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"This turns the PDE into","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"sum_i jhatu_ihattheta_jintnablaphi_i(mathbfr)\nbeginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix\nnablaphi_j(mathbfr) d Omega = sum_i hatu_iintphi_i(mathbfr)P(mathbfr)dOmega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"In matrix form this can be written as","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbfhatu^top mathbfK mathbfhattheta = mathbfhatu^topmathbff","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"As this equation needs to hold for arbitrary mathbfhatu we need to solve the linear system","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbfK mathbfhattheta = mathbff","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"where the stiffness matrix","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbfK_ij = intnablaphi_i(mathbfr)\nbeginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix\nnablaphi_j(mathbfr) d Omega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"and force vector","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbff_i = intphi_i(mathbfr)P(mathbfr)dOmega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"have been introduced.","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"Lastly, we need to look at how the integrals are calculated. This is done by turning the integral into a sum of integrals over the elements E (in our case traingles) of the grid. The integral is then solved using Gaussian quadrature","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"intnablaphi_i(mathbfr)\nbeginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr)endbmatrix\nnablaphi_j(mathbfr) d Omega = sum_Esum_iomega_k nablaphi_i(mathbfq_k)\nbeginbmatrixb_x(mathbfq_k)  0  0  b_y(mathbfq_k)endbmatrix\nnablaphi_j(mathbfq_k)","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"where omega_i are the quadrature weights and mathbfq_i the quadrature points. The final trick is to use the base functions of a reference element and then just do a coordinate transformation to the actual coordinates. This yields","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"intnablaphi_i(mathbfr) dOmega = sum_Esum_komega_k J^-1^topwidetildenablaphi_i(tildemathbfq_k)\nbeginbmatrixb_x(mathbfq_k)  0  0  b_y(mathbfq_k)endbmatrix\nJ^-1^topwidetildenablaphi_j(tildemathbfq_k)det(J)","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"where the quantities marked with a tilde are the reference quantities and J is the Jacobian of the coordinate transform.","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"Using these results we can create the stiffness matrix. The force vector can be created similarly using","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"intphi_i(mathbfr)P(mathbfr)  dOmega = sum_Esum_komega_k J^-1^toptildephi_i(tildemathbfq_k) P(mathbfq_k)det(mathbfJ)","category":"page"},{"location":"implementation/finite/#Dynamic-Solution","page":"Finite Element Method","title":"Dynamic Solution","text":"","category":"section"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"We start by rewriting the second order differential equation as a system of two first order differential equations","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"beginbmatrix100m(mathbfr)endbmatrixfracddtbeginbmatrixtheta(mathbfr)omega(mathbfr) endbmatrix=\nbeginbmatrixomega(mathbfr)-d(mathbfr)omega(mathbfr) + nabla(mathbfb(mathbfr)nablatheta(mathbfr))endbmatrix + \nbeginbmatrix0P(mathbfr)endbmatrix","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"After multiplying by a test function and integrating this equation can be written as","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"beginbmatrixmathbfM_1  0  0  mathbfM_2endbmatrix fracddt beginbmatrixhatthetahatomegaendbmatrix =\nbeginbmatrix0  mathbfK_1mathbfK_2  mathbfK_3 endbmatrixbeginbmatrixhatthetahatomegaendbmatrix + beginbmatrix0 mathbffendbmatrix","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"where","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbfM_1ij = intphi_i(mathbfr) phi_j(mathbfr)  dOmega qquadmathbfM_2ij = int m(mathbfr)phi_i(mathbfr) phi_j(mathbfr)  dOmega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"beginalign*\nmathbfK_1ij = intphi_i(mathbfr) phi_j(mathbfr)  dOmega qquadmathbfK_2ij = -int d(mathbfr)phi_i(mathbfr) phi_j(mathbfr)  dOmega\nmathbfK_3ij = -intnablaphi_i(mathbfr)beginbmatrixb_x(mathbfr)  0  0  b_y(mathbfr) endbmatrix nablaphi_j(mathbfr) dOmega\nendalign*","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"and","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"mathbff = int P(mathbfr)phi_i(mathbfr) dOmega","category":"page"},{"location":"implementation/finite/","page":"Finite Element Method","title":"Finite Element Method","text":"The integrals can then be solved in the way described in the previous section.","category":"page"},{"location":"implementation/static/#Implementation-of-the-Susceptance-Learning","page":"Learn Susceptances","title":"Implementation of the Susceptance Learning","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The line susceptance are learned by comparing the static solution obtained from the continuous model with the solutions obtained from the power flow equations for the discrete case. Learning is done by learn_susceptances. The process consists of the following steps","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Load the discrete models\nCreate all the necessary matrices\nCreate all projectors\nCreate the force vectors\nAssemble the training and test data sets\nDo the learning\nCalculate the predictions\nCalculate the loss values for the predictions","category":"page"},{"location":"implementation/static/#Load-the-discrete-models","page":"Learn Susceptances","title":"Load the discrete models","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"First the grid is loaded from a GMSH file. After this we load all the discrete models used for the training and the test. This is all done as described in Creating Models. Each single discrete model corresponds to one dispatch.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.discrete_models","category":"page"},{"location":"implementation/static/#Create-all-the-necessary-matrices","page":"Learn Susceptances","title":"Create all the necessary matrices","text":"","category":"section"},{"location":"implementation/static/#Motivation","page":"Learn Susceptances","title":"Motivation","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The matrices created are motivated as follows. We begin with the stiffness matrix. Recall that it is given by (dropping the transformation of the gradients as this taken care of by Ferrite)","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"mathbfK_ij = sum_Esum_komega_k nablaphi_i(mathbfq_k)\nbeginbmatrixb_x(mathbfq_k)  0  0  b_y(mathbfq_k)endbmatrix\nnablaphi_j(mathbfq_k)det(J)","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Note that the sum over k can be written as","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":" beginbmatrixnablaphi_i(mathbfq_1)nablaphi_i(mathbfq_2)vdotsendbmatrix^top\nbeginbmatrixb_x(mathbfq_1)  0  0  0  cdots 0  b_y(mathbfq_1)  0  0  cdots0  0  b_x(mathbfq_2)  0  cdots  0  0  0  b_y(mathbfq_2)  cdotsvdotsvdotsvdotsvdotsddotsendbmatrix\nbeginbmatrixnablaphi_j(mathbfq_1)nablaphi_j(mathbfq_2)vdotsendbmatrix","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"To eliminate the sum over E, we can pull the determinant and quadrature weight into the gradient and label all quadrature points continuously. Introducing the matrix mathbfA which is made of 1times2 blocks with","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"mathbfA_ij = (nabla phi_i(mathbfq_j))^top sqrtomega_jdet(J_j)","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"where omega_j and J_j are the weight and determinant that belong to quadrature point j. It is obvious that we can write the stiffness matrix as","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"mathbfK = mathbfA mathrmdiag(b_x(mathbfq_1) b_y(mathbfq_1) dots) mathbfA^top","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Therefore, the first matrix we need to create is mathbfA. As we need the values of b in the quadrature points, we will collect the coordinates of the quadrature points in the process of creating mathbfA. The next matrix we need is related to enforcing the value of the slack bus. This means that at one node the solution to the static problem is fixed at 0. This is achieved by setting the row and column of the stiffness matrix corresponding to that node to zero and adding a 1 on the diagonal for that node. Additionally the corresponding entry of the force vector will be set to zero. The next matrix therefore has only one entry: 1 on the diagonal corresponding to the slack node. Finally, we need to create one more matrix. Similar to the above, we want to write the force vector as","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"mathbff = mathbfA_f beginbmatrix P(mathbfq_1) P(mathbfq_2)  vdots endbmatrix","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The derivation is very similar to the above and we find","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"mathbfA_fij = phi_i(mathbfq_j) omega_j det(J_j)","category":"page"},{"location":"implementation/static/#Implementation","page":"Learn Susceptances","title":"Implementation","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"First the continuous model is loaded as described in Creating Models. We begin by creating allocating the required matrices, getting the number of base functions, and initializing the quadrature point iterators.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"q_coords = zeros(getnquadpoints(model.cellvalues) * size(model.grid.cells, 1), 2)\nAf = zeros(ndofs(model.dh₁),\n    getnquadpoints(model.cellvalues) * size(model.grid.cells, 1))\nAk = zeros(ndofs(model.dh₁),\n    2 * getnquadpoints(model.cellvalues) * size(model.grid.cells, 1))\n\nn_basefuncs = getnbasefunctions(model.cellvalues)\nix_af = 1\nix_ak = 1","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Afterwards we loop over all cells using the CellIterator. For each cell the cell values need to be initialized so the structure contains the correct gradient values. We also get the degrees of freedom that are associated with this cell.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"for (ix, cell) in enumerate(CellIterator(model.dh₁))\n    Ferrite.reinit!(model.cellvalues, cell)\n    dofs = celldofs(cell)","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Next, we loop over all the quadrature points in the cell. First we get the coordinates of that point and the value of the product of the quadrature weight and the Jacobian determinant at this quadrature point. The coordinates will be saved in the associated matrix.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"    for q_point in 1:getnquadpoints(model.cellvalues)\n        x = spatial_coordinate(model.cellvalues, q_point, getcoordinates(cell))\n        dΩ = getdetJdV(model.cellvalues, q_point)\n        q_coords[ix_af, :] = x","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Next we iterate over the base functions associated with that cell (only base functions associated with this cell have a non-zero contribution in the quadrature points). We can easily obtain the value and its gradient at the quadrature point from Ferrite and fill the matrix as described in the motivation section.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"        for i in 1:n_basefuncs\n            φᵢ = shape_value(model.cellvalues, q_point, i)\n            ∇φᵢ = shape_gradient(model.cellvalues, q_point, i)\n            Af[dofs[i], ix_af] = φᵢ * dΩ\n            Ak[dofs[i], ix_ak:ix_ak+1] = ∇φᵢ * sqrt(dΩ)\n        end","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Finally, we need to increase the quadrature point iterators.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"        ix_af += 1\n        ix_ak += 2\n    end\nend","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The last thing left to do is to enforce the slack node. The correct degree of freedom can be straightforwardly obtained from the ConstraintHandler.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Ak[model.ch.prescribed_dofs, :] .= 0.0\nAf[model.ch.prescribed_dofs, :] .= 0.0\ndim = zeros(ndofs(model.dh₁), ndofs(model.dh₁))\ndim[model.ch.prescribed_dofs, model.ch.prescribed_dofs] .= 1","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.assemble_matrices_static","category":"page"},{"location":"implementation/static/#Create-all-projectors","page":"Learn Susceptances","title":"Create all projectors","text":"","category":"section"},{"location":"implementation/static/#Motivation-2","page":"Learn Susceptances","title":"Motivation","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"While Ferrite has the option to obtain values at arbitrary point given a DofHandler and the nodal values doing this at every step of the training is time consuming. Additionally, this is not compatible with the automatic differentiation of Flux. However, we can easily turn the interpolation into an easy matrix multiplication.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Let's revisit the way that we can obtain values at arbitrary points using the finite element method. In general a field  u(mathbfr) is expanded as follows","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"u(mathbfr) = sum_i phi_i(mathbfr) hatu_i","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"where phi_i are the base functions and hatu_i are the nodal values. As the position of the quadrature points and the discrete values in the grid does not change we can simply calculate phi(mathbfr) for all these points and then multiply them by the nodal values. As an example take the values of b_x and b_y in the first quadrature points they can be obtained by","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"beginbmatrixb_x(mathbfq_1)  b_y(mathbfq_2)endbmatrix = \nbeginbmatrixphi_1(mathbfq_1)  0  phi_2(mathbfq_1)  0  dots  0  phi_1(mathbfq_1)  0  phi_2(mathbfq_1)  dotsendbmatrix\nbeginbmatrix\nwidehatb_x_1  widehatb_y_1  vdots\nendbmatrix","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"info: Info\nIn general we wouldn't need to project values of P(mathbfr) but rather use the actual values. However, the distribution has been obtained through the heat equation diffusion and therefore we only have the values on the nodes. The DofHandler is the same as the one used for the steady state solution.","category":"page"},{"location":"implementation/static/#Implementation-2","page":"Learn Susceptances","title":"Implementation","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"We need to create three projection matrices: for the buses in the discrete model, for the sucsceptances onto the quadrature points, and for the power onto the quadrature points. To demonstrate the creation of these matrices with Ferrite, we show the assembly of the projection matrix for the buses of the discrete model.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"We start by allocating the memory for the matrix, getting the function interpolations used, and obtaining the coordinates of the grid nodes.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"func_interpolations = Ferrite.get_func_interpolations(model.dh₁, :u)\ngrid_coords = [node.x for node in model.grid.nodes]\nn_base_funcs = getnbasefunctions(model.cellvalues)\nθ_proj = zeros(size(dm.th, 1), ndofs(model.dh₁))","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Next, we loop over all the coordinates in the discrete model. Using the PointEvalHandler allows us to find the cell in which the coordinate is located. Additionally, it yields the position of the coordinate within the cell in reference coordinates. In case the coordinate is not inside the grid (for example, some buses are located on islands), we choose the closest node of the grid.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"for (i, point) in enumerate(eachrow(dm.coord))\n    ph = PointEvalHandler(model.grid, [Ferrite.Vec(point...)], warn = :false)\n    if ph.cells[1] === nothing\n        min_ix = argmin([norm(coord .- Ferrite.Vec(dm.coord[i, :]...))\n                         for coord in grid_coords])\n        ph = PointEvalHandler(model.grid, [grid_coords[min_ix]])\n    end","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Next, we obtain the values of the base functions at this point, get the degrees of freedom, and assemble the matrix.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"    pv = Ferrite.PointScalarValuesInternal(ph.local_coords[1], func_interpolations[1])\n    cell_dofs = Vector{Int}(undef, ndofs_per_cell(model.dh₁, ph.cells[1]))\n    Ferrite.celldofs!(cell_dofs, model.dh₁, ph.cells[1])\n    for j in 1:n_base_funcs\n        θ_proj[i, cell_dofs[j]] = pv.N[j]\n    end\nend","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The assembly of the quadrature point projectors works analogously. We do not need to check whether the points are inside the grid. The pattern of the projector for the susceptances is obtained as follows","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"q_proj_b[2 * i - 1, 2 * cell_dofs[j] - 1] = pv.N[j]\nq_proj_b[2 * i, 2 * cell_dofs[j]] = pv.N[j]","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.projectors_static","category":"page"},{"location":"implementation/static/#Create-the-force-vectors","page":"Learn Susceptances","title":"Create the force vectors","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The creation of the force vectors is quite simple. We update the model using the discrete models so that it contains the correct power data. Then we use the projection matrix to obtain the values in the quadrature points and finally use the Af matrix to contain the force vector.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"for i in 1:size(training, 1)\n    update_model!(model, :p, training[i], tf, κ = κ, σ = σ)\n    f_train[:, i] = Af * q_proj * model.p_nodal\nend","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.assemble_f_static","category":"page"},{"location":"implementation/static/#Assemble-the-training-and-test-data-sets","page":"Learn Susceptances","title":"Assemble the training and test data sets","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"We simply create a matrix that contains all the ground truth data, i.e., all the steady state angles of the discrete models. This allows us to train on all the data sets simultaneously.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"for i in 1:size(training, 1)\n    t_train[:, i] = training[i].th\nend","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.assemble_disc_theta","category":"page"},{"location":"implementation/static/#Do-the-learning","page":"Learn Susceptances","title":"Do the learning","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"Doing the actual learning is straightforward. We use Flux to calculate the gradient and update the parameters. At each step we assemble the stiffness matrix. Then we obtain the nodal values of the steady state solution by solving the linear system mathbfKmathbftheta_0 = mathbff and project them onto discrete bus locations. The loss function is given by the Huber loss. An epoch looks like","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"for batch in 1:n_batches\n    local loss\n    gs = Flux.gradient(param) do\n        btemp = max.(b, bmin)\n        K = A * sparse(1:n_q, 1:n_q, q_proj * btemp) * A' + dim\n        θ = proj * (K \\ f_train[:,\n            shuffled_ix[((batch - 1) * batch_size + 1):(batch * batch_size)]])\n        loss = Flux.huber_loss(θ,\n            t_train[:,\n                shuffled_ix[((batch - 1) * batch_size + 1):(batch * batch_size)]],\n            delta = δ)\n    end\n    losses[e, batch] = loss\n    if (mod(e, 50) == 0 && batch == 3)\n        println(string(e) * \", \" * string(mean(losses[e, :])))\n    end\n    Flux.update!(opt, param, gs)\nend","category":"page"},{"location":"implementation/static/#Calculate-the-predictions","page":"Learn Susceptances","title":"Calculate the predictions","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The predictions are calculated like shown in the previous section.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.prediction","category":"page"},{"location":"implementation/static/#Calculate-the-loss-values-for-the-predictions","page":"Learn Susceptances","title":"Calculate the loss values for the predictions","text":"","category":"section"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"The Huber loss for all predictions is calculated.","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"train_losses = vcat(Flux.huber_loss(train_pred,\n    t_train,\n    delta = δ,\n    agg = x -> mean(x, dims = 1))...)","category":"page"},{"location":"implementation/static/","page":"Learn Susceptances","title":"Learn Susceptances","text":"See: ContGridModML.get_losses","category":"page"},{"location":"api/public/#Public-API","page":"Public","title":"Public API","text":"","category":"section"},{"location":"api/public/","page":"Public","title":"Public","text":"Exported functions and types of ContGridMod.jl.","category":"page"},{"location":"api/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"api/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 2:2","category":"page"},{"location":"api/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"api/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"api/public/#Structs","page":"Public","title":"Structs","text":"","category":"section"},{"location":"api/public/","page":"Public","title":"Public","text":"ContGridModML.StaticSol\nContGridModML.DynamicSol","category":"page"},{"location":"api/public/#ContGridModML.StaticSol","page":"Public","title":"ContGridModML.StaticSol","text":"Contains the results of the static training.\n\nb::Vector{T} where T<:Real: Vector of the nodal susceptances. The ordering is alternating b_x and b_y. The values are ordered in the same order as in the DoF handler cm.dh₁.\n\nlosses::Matrix{T} where T<:Real: The training losses. The row corresponds to the epoch and the column to the data set.\n\ntrain_pred::Matrix{T} where T<:Real: Prediction of the values for each training data set with the trained values.\n\ntest_pred::Matrix{T} where T<:Real: Prediction of the values for each test data set with the trained values.\n\nt_train::Matrix{T} where T<:Real: Ground truth data for the training data sets.\n\nt_test::Matrix{T} where T<:Real:  qprojb Ground truth data for the test data sets.\n\ntrain_losses::Vector{T} where T<:Real: Loss values for all training data sets.\n\ntest_losses::Vector{T} where T<:Real: Loss values for all test data sets.\n\nmodel::ContGridModML.ContModel: The continuous model with the updated susceptances.\n\ntrain_models::Vector{<:ContGridModML.DiscModel}: The discrete models used for training.\n\ntest_models::Vector{<:ContGridModML.DiscModel}: The discrete models used for testing.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ContGridModML.DynamicSol","page":"Public","title":"ContGridModML.DynamicSol","text":"Contains the results of the dynamic training.\n\ntrain_ix::Vector{<:Integer}: Indices of the generators used to create the training ground truth data.\n\ntest_ix::Vector{<:Integer}: Indices of the generators used to create the training ground truth data.\n\ncomp_ix::Vector{<:Integer}: Indices of the nodes on which the frequency is compared to calculate the loss function.\n\nm::Vector{<:Real}: Vector of the nodal inertia. The values are ordered in the same order as in the DoF handler cm.dh₁.\n\nd::Vector{<:Real}: Vector of the nodal damping. The values are ordered in the same order as in the DoF handler cm.dh₁.\n\ncoeffs::Vector{<:Real}: Coefficients of the modal expansion of the dynamical parameters. The realtion between the nodal values, the coefficients, and the eigenvectors is given by\nn = size(coeffs, 1) ÷ 2\nm = eve[:, 1:n] * coeffs[1:n]\nd = eve[:, 1:n] * coeffs[n+1:end]\n\neve::Matrix{<:Real}: Eigenvectors of the unweighted Laplacian of the grid of the continuous model.\n\nlosses::Matrix{<:Real}: The training losses. The row corresponds to the epoch and the column to the data set.\n\ntrain_losses::Vector{<:Real}: Loss values for all training data sets.\n\ntest_losses::Vector{<:Real}: Loss values for all test data sets.\n\nmodel::ContGridModML.ContModel: The continuous model with updated inertia and damping.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Functions","page":"Public","title":"Functions","text":"","category":"section"},{"location":"api/public/","page":"Public","title":"Public","text":"learn_susceptances\nlearn_dynamical_parameters\nload_sol\nsave_sol","category":"page"},{"location":"api/public/#ContGridModML.learn_susceptances","page":"Public","title":"ContGridModML.learn_susceptances","text":"learn_susceptances(\n;\n    train_folder,\n    test_folder,\n    mesh_fn,\n    n_epoch,\n    n_batch,\n    n_modes,\n    n_coeffs,\n    comp_ix,\n    bx_init,\n    by_init,\n    rng,\n    opt,\n    bmin,\n    δ\n) -> ContGridModML.StaticSol{Float64}\n\n\nLearn the line susceptances.\n\nThe parameters are learned by calculating the stable solution for multiple dispatches and comparing them to the results from the discrete model. The comparison points are obtained by using the liear approximation provided by the finite element method.\n\nArguments\n\ntrain_fn::String = MODULE_FOLDER * \"/data/ml/training_\": The names of the files   containing the training scenarios. The files must be labeled train_fn1.h5,   train_fn2.h5, etc.\ntest_fn::String = MODULE_FOLDER * \"/data/ml/test_\": The names of the files   containing the test scenarios. The files must be labeled test.h5, test.h5, etc.\ngrid_fn::String = MODULE_FOLDER * \"/data/panta.msh\": Name of the file containing the mesh\nn_train::Int = 48: Number of training data sets\nn_test::Int = 12: Number of test data sets\nn_epochs::Int = 10000: Number of epochs\nn_batches::Int = 3: Number of batches per epoch\ntf::Real = 0.05: Duration of the heat equation diffusion for the power distribution \nκ::Real = 0.02: Diffusion constant of the heat equation diffusion for the power   distribution\nσ::Real = 0.01: Standard deviation for the initial Gaussian distribution of the   parameters\nrng::AbstractRNG = Xoshiro(): Random number generator used to draw all random numbers\nbmin::Real = 0.1: Minimimum value of the suscpetances\nδ = 0.5: Parameter of the Huber loss function\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ContGridModML.learn_dynamical_parameters","page":"Public","title":"ContGridModML.learn_dynamical_parameters","text":"learn_dynamical_parameters(\n;\n    dm_fn,\n    cm_fn,\n    dP,\n    n_train,\n    n_test,\n    dt,\n    tf,\n    disc_solve_kwargs,\n    cont_solve_kwargs,\n    lambda_solve_kwargs,\n    seed,\n    n_points,\n    m_init,\n    d_init,\n    n_coeffs,\n    n_modes,\n    n_epochs,\n    max_function,\n    train_ix,\n    test_ix\n) -> ContGridModML.DynamicSol\n\n\nLearn the inertia and damping distribution for the continuous model.\n\nThe frequency response of faults at multiple generators are compared on homogeneously spread buses across the grid. The gradient is calculated using an adjoint sensitivity method and the updates to the parameters are calculated using a constraint gradient descent method.\n\nArguments\n\ndm_fn::String = MODULE_FOLDER * \"/data/dm.h5\": File name of the discrete model\ncm_fn::String = MODULE_FOLDER * \"/data/cm.h5\": File name of the continuous model\ndP::Real = -9.0: Fault size to be simulated\nn_train::Integer = 12: Amount of faults to consider for training\nn_test::Integer = 4: Amount of faults to consider for testing\ndt::Real = 0.01: Step size at which the solutions of the ODEs are saved\ntf::Real = 25.0: Duration of the simulations\ndisc_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(): Keyword arguments passed  to the ODE solver for the discrete model\ncont_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(): Keyword arguments passed  to the ODE solver for the continuous model\nlambda_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(:saveat => 0.1,  :abstol => 1e-3, :reltol => 1e-2): Keyword arguments passed to the ODE solver of the  adjoint equations\nseed::Union{Nothing, Integer} = 1709: Seed for the random number generator to be used   to pick the training and test generators\nσ = 0.05: Standard deviation of the Gaussian used to distribute the fault\nn_points = 40: Number of points for comparison along the largest dimension\nn_coeffs = 1: Number of coefficients that are non-zero at the beginning of the  training. They correspond to the n_coeffs lowest modes of the Laplacian.\nn_modes = 20: Number of modes the Laplacian that are used to expand the parameters.\nn_epochs = 8000: Number of epochs used for the training.\nmax_function::Function = (x) -> 30 * 2^(x / 500): Function that changes the magnitude  of the change vector of the parameters wrt the epoch.\ntrain_ix::Union{Nothing, Vector{<:Integer}} = nothing: Indices of the generators used  for training if they are not supposed to be picked randomly.\ntest_ix::Union{Nothing, Vector{<:Integer}} = nothing: Indices of the generators used  for testing if they are not supposed to be picked randomly.\n\nwarning: Warning\nIf the training and test generators are not supposed to be picked randomly, both train_ix and test_ix need to be passed.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ContGridModML.load_sol","page":"Public","title":"ContGridModML.load_sol","text":"load_sol(\n    fn::String\n) -> Union{ContGridModML.DynamicSol, ContGridModML.StaticSol}\n\n\nLoad a solution from a HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ContGridModML.save_sol","page":"Public","title":"ContGridModML.save_sol","text":"save_sol(fn::String, sol::ContGridModML.ContSol)\n\n\nSave a solution to a HDF5 file.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/cont_dynamics/#Cont_dynamics.jl","page":"Cont_dynamics.jl","title":"Cont_dynamics.jl","text":"","category":"section"},{"location":"api/internal/cont_dynamics/#Functions","page":"Cont_dynamics.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/cont_dynamics/","page":"Cont_dynamics.jl","title":"Cont_dynamics.jl","text":"Modules = [ContGridModML]\nPages = [\"cont_dynamics.jl\"]","category":"page"},{"location":"api/internal/cont_dynamics/#ContGridModML.cont_dynamics-Tuple{ContGridModML.ContModel, Real, Vector{<:Real}, Real}","page":"Cont_dynamics.jl","title":"ContGridModML.cont_dynamics","text":"cont_dynamics(\n    model::ContGridModML.ContModel,\n    p::Real,\n    coord::Vector{<:Real},\n    tf::Real;\n    alg,\n    solve_kwargs\n) -> SciMLBase.ODESolution\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/mesh/#Mesh.jl","page":"Mesh.jl","title":"Mesh.jl","text":"","category":"section"},{"location":"api/internal/mesh/#Functions","page":"Mesh.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/mesh/","page":"Mesh.jl","title":"Mesh.jl","text":"Modules = [ContGridModML]\nPages = [\"mesh.jl\"]","category":"page"},{"location":"api/internal/mesh/#ContGridModML.get_mesh-Tuple{String}","page":"Mesh.jl","title":"ContGridModML.get_mesh","text":"get_mesh(\n    file::String;\n    kwargs...\n) -> Tuple{Ferrite.Grid, Real}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/mesh/#ContGridModML.get_mesh_from_mesh-Tuple{String}","page":"Mesh.jl","title":"ContGridModML.get_mesh_from_mesh","text":"get_mesh_from_mesh(\n    file::String\n) -> Tuple{Ferrite.Grid, Real}\n\n\nLoad a grid from a gmsh file. The file needs to contain a field ScaleFactor.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#Tools.jl","page":"Tools.jl","title":"Tools.jl","text":"","category":"section"},{"location":"api/internal/tools/","page":"Tools.jl","title":"Tools.jl","text":"Description of various helper functions. At the moment they are all related to loading and saving the solution structures.","category":"page"},{"location":"api/internal/tools/#Contents","page":"Tools.jl","title":"Contents","text":"","category":"section"},{"location":"api/internal/tools/","page":"Tools.jl","title":"Tools.jl","text":"Pages = [\"tools.md\"]\nDepth = 2:2","category":"page"},{"location":"api/internal/tools/#Index","page":"Tools.jl","title":"Index","text":"","category":"section"},{"location":"api/internal/tools/","page":"Tools.jl","title":"Tools.jl","text":"Pages = [\"tools.md\"]","category":"page"},{"location":"api/internal/tools/#Functions","page":"Tools.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/tools/","page":"Tools.jl","title":"Tools.jl","text":"Modules = [ContGridModML]\nPages = [\"tools.jl\"]","category":"page"},{"location":"api/internal/tools/#ContGridModML.albers_projection-Tuple{Matrix{<:Real}}","page":"Tools.jl","title":"ContGridModML.albers_projection","text":"albers_projection(\n    coord::Matrix{<:Real};\n    lon0,\n    lat0,\n    lat1,\n    lat2,\n    R\n) -> Matrix{<:Real}\n\n\nApply the Albers projection to a vector of coordinates. The coordinates need to be given as latitude, longitude. See https://en.wikipedia.org/wiki/Albers_projection\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.cont_from_dict-Tuple{Dict{String}}","page":"Tools.jl","title":"ContGridModML.cont_from_dict","text":"cont_from_dict(\n    data::Dict{String}\n) -> ContGridModML.ContModel\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.cont_to_dict-Tuple{ContGridModML.ContModel}","page":"Tools.jl","title":"ContGridModML.cont_to_dict","text":"cont_to_dict(\n    cm::ContGridModML.ContModel\n) -> Dict{String, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dict_to_dynamic-Tuple{Dict{String}}","page":"Tools.jl","title":"ContGridModML.dict_to_dynamic","text":"dict_to_dynamic(\n    data::Dict{String}\n) -> ContGridModML.DynamicSol\n\n\nLoad a dynamic solution from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dict_to_hdf5-Tuple{Dict, HDF5.H5DataStore}","page":"Tools.jl","title":"ContGridModML.dict_to_hdf5","text":"dict_to_hdf5(data::Dict, fid::HDF5.H5DataStore)\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dict_to_sol-Tuple{Dict{String}}","page":"Tools.jl","title":"ContGridModML.dict_to_sol","text":"dict_to_sol(\n    data::Dict{String}\n) -> Union{ContGridModML.DynamicSol, ContGridModML.StaticSol}\n\n\nLoad a solution from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dict_to_sparse-Tuple{Dict{String, Any}}","page":"Tools.jl","title":"ContGridModML.dict_to_sparse","text":"dict_to_sparse(\n    dict::Dict{String, Any}\n) -> SparseArrays.SparseMatrixCSC\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dict_to_static-Tuple{Dict{String}}","page":"Tools.jl","title":"ContGridModML.dict_to_static","text":"dict_to_static(\n    data::Dict{String}\n) -> ContGridModML.StaticSol\n\n\nLoad a static solution from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.disc_from_dict-Tuple{Dict{String}}","page":"Tools.jl","title":"ContGridModML.disc_from_dict","text":"disc_from_dict(\n    dict::Dict{String}\n) -> ContGridModML.DiscModel\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.disc_to_dict-Tuple{ContGridModML.DiscModel}","page":"Tools.jl","title":"ContGridModML.disc_to_dict","text":"disc_to_dict(dm::ContGridModML.DiscModel) -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.distribute_country_load-Tuple{Dict{String, Any}, Dict{String, <:Real}}","page":"Tools.jl","title":"ContGridModML.distribute_country_load","text":"distribute_country_load(\n    grid::Dict{String, Any},\n    country::Dict{String, <:Real}\n) -> Dict{String, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.dynamic_to_dict-Tuple{ContGridModML.DynamicSol}","page":"Tools.jl","title":"ContGridModML.dynamic_to_dict","text":"dynamic_to_dict(\n    sol::ContGridModML.DynamicSol\n) -> Dict{String, Any}\n\n\nTurn a dynamic solution into a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.hdf5_to_dict-Tuple{HDF5.H5DataStore}","page":"Tools.jl","title":"ContGridModML.hdf5_to_dict","text":"hdf5_to_dict(fid::HDF5.H5DataStore) -> Dict{String, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.import_border-Tuple{String}","page":"Tools.jl","title":"ContGridModML.import_border","text":"import_border(filename::String) -> Any\n\n\nImport border from a json file, apply the Albers projection and rescale it such that the longest dimension is 1. The coordinates need to be given as latitude, longitude.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.load_discrete_model-Tuple{String, Float64}","page":"Tools.jl","title":"ContGridModML.load_discrete_model","text":"load_discrete_model(\n    dataname::String,\n    scaling_factor::Float64\n) -> ContGridModML.DiscModel\n\n\nLoad a discrete model from a file and rescale the coordinates to match the continuous model.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.load_discrete_model_from_json-Tuple{String, Bool, Real}","page":"Tools.jl","title":"ContGridModML.load_discrete_model_from_json","text":"load_discrete_model_from_json(\n    dataname::String,\n    project::Bool,\n    scale_factor::Real\n) -> ContGridModML.DiscModel\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.load_discrete_model_from_powermodels-Tuple{Dict{String, Any}, Bool, Real}","page":"Tools.jl","title":"ContGridModML.load_discrete_model_from_powermodels","text":"load_discrete_model_from_powermodels(\n    data::Dict{String, Any},\n    project::Bool,\n    scale_factor::Real\n) -> ContGridModML.DiscModel\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.load_model-Tuple{String}","page":"Tools.jl","title":"ContGridModML.load_model","text":"load_model(fn::String) -> Any\n\n\nLoad a continuous or discrete model from a hdf5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.load_sol-Tuple{String}","page":"Tools.jl","title":"ContGridModML.load_sol","text":"load_sol(\n    fn::String\n) -> Union{ContGridModML.DynamicSol, ContGridModML.StaticSol}\n\n\nLoad a solution from a HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.model_to_dict-Tuple{ContGridModML.GridModel}","page":"Tools.jl","title":"ContGridModML.model_to_dict","text":"model_to_dict(\n    model::ContGridModML.GridModel\n) -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.opf_from_country-Tuple{Dict{String, Any}, Dict{String, <:Real}}","page":"Tools.jl","title":"ContGridModML.opf_from_country","text":"opf_from_country(\n    grid::Dict{String, Any},\n    country::Dict{String, <:Real}\n) -> Dict{String, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.remove_nan-Tuple{Dict{String, Any}}","page":"Tools.jl","title":"ContGridModML.remove_nan","text":"remove_nan(grid::Dict{String, Any}) -> Dict{String, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.save_model-Tuple{String, ContGridModML.GridModel}","page":"Tools.jl","title":"ContGridModML.save_model","text":"save_model(fn::String, model::ContGridModML.GridModel)\n\n\nSave a continuous or discrete model to a hdf5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.save_sol-Tuple{String, ContGridModML.ContSol}","page":"Tools.jl","title":"ContGridModML.save_sol","text":"save_sol(fn::String, sol::ContGridModML.ContSol)\n\n\nSave a solution to a HDF5 file.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.sol_to_dict-Tuple{ContGridModML.ContSol}","page":"Tools.jl","title":"ContGridModML.sol_to_dict","text":"sol_to_dict(sol::ContGridModML.ContSol) -> Dict{String, Any}\n\n\nTurn a solution into a dict.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.sparse_to_dict-Tuple{SparseArrays.SparseMatrixCSC}","page":"Tools.jl","title":"ContGridModML.sparse_to_dict","text":"sparse_to_dict(\n    sm::SparseArrays.SparseMatrixCSC\n) -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.stable_sol!-Tuple{ContGridModML.ContModel}","page":"Tools.jl","title":"ContGridModML.stable_sol!","text":"stable_sol!(cm::ContGridModML.ContModel)\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/tools/#ContGridModML.static_to_dict-Tuple{ContGridModML.StaticSol}","page":"Tools.jl","title":"ContGridModML.static_to_dict","text":"static_to_dict(\n    sol::ContGridModML.StaticSol\n) -> Dict{String, Any}\n\n\nTurn a static solution into a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/plot/#Plot.jl","page":"Plot.jl","title":"Plot.jl","text":"","category":"section"},{"location":"api/internal/plot/#Functions","page":"Plot.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/plot/","page":"Plot.jl","title":"Plot.jl","text":"Modules = [ContGridModML]\nPages = [\"plot.jl\"]","category":"page"},{"location":"api/internal/plot/#ContGridModML.nodal_plot-Tuple{ContGridModML.ContModel, Symbol}","page":"Plot.jl","title":"ContGridModML.nodal_plot","text":"nodal_plot(\n    model::ContGridModML.ContModel,\n    fieldname::Symbol;\n    kwargs...\n) -> Makie.Figure\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/plot/#ContGridModML.nodal_plot-Tuple{ContGridModML.ContModel, Vector{<:Real}}","page":"Plot.jl","title":"ContGridModML.nodal_plot","text":"nodal_plot(\n    model::ContGridModML.ContModel,\n    val::Vector{<:Real};\n    logarithmic,\n    colormap,\n    colorbar,\n    decorations,\n    fig_args,\n    ax_args,\n    cbar_args\n) -> Makie.Figure\n\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#Dynamic.jl","page":"Dynamic.jl","title":"Dynamic.jl","text":"","category":"section"},{"location":"api/internal/dynamic/","page":"Dynamic.jl","title":"Dynamic.jl","text":"Description of internally used functions for the learning of the dynamic parameters.","category":"page"},{"location":"api/internal/dynamic/#Contents","page":"Dynamic.jl","title":"Contents","text":"","category":"section"},{"location":"api/internal/dynamic/","page":"Dynamic.jl","title":"Dynamic.jl","text":"Pages = [\"dynamic.md\"]\nDepth = 2:2","category":"page"},{"location":"api/internal/dynamic/#Index","page":"Dynamic.jl","title":"Index","text":"","category":"section"},{"location":"api/internal/dynamic/","page":"Dynamic.jl","title":"Dynamic.jl","text":"Pages = [\"dynamic.md\"]","category":"page"},{"location":"api/internal/dynamic/#Functions","page":"Dynamic.jl","title":"Functions","text":"","category":"section"},{"location":"api/internal/dynamic/","page":"Dynamic.jl","title":"Dynamic.jl","text":"Modules = [ContGridModML]\nPages = [\"dynamic.jl\"]","category":"page"},{"location":"api/internal/dynamic/#ContGridModML.assemble_f_dynamic-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel, Vector{<:Integer}, Union{Real, Vector{<:Real}}, SparseArrays.SparseMatrixCSC}","page":"Dynamic.jl","title":"ContGridModML.assemble_f_dynamic","text":"assemble_f_dynamic(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel,\n    fault_ix::Vector{<:Integer},\n    dP::Union{Real, Vector{<:Real}},\n    Af::SparseArrays.SparseMatrixCSC\n) -> Matrix{Float64}\n\n\nAssemble all the force vectors for the dynamical simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.assemble_matrices_dynamic-Tuple{ContGridModML.ContModel}","page":"Dynamic.jl","title":"ContGridModML.assemble_matrices_dynamic","text":"assemble_matrices_dynamic(\n    model::ContGridModML.ContModel\n) -> NTuple{4, SparseArrays.SparseMatrixCSC{Float64, Int64}}\n\n\nCreate all the necessary finite element matrices from a given model.\n\nThe matrices returned are\n\nM_const the constant (non-parameter dependent) part of the mass matrix\nK_const the constant (non-parameter dependent) part of the stiffness matrix\nA the matrix needed to create the non-constant part of both the mass and stiffness   matrices. For example the mass matrix can be calculated as    M = M_const + A * m_quad * A'\nAf the matrix needed to create the force vector as f = Af * (p_quad + fault_quad)\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.cont_dyn-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{<:Real}, Vector{<:Real}, Real}","page":"Dynamic.jl","title":"ContGridModML.cont_dyn","text":"cont_dyn(\n    M::SparseArrays.SparseMatrixCSC,\n    K::SparseArrays.SparseMatrixCSC,\n    f::Vector{<:Real},\n    u₀::Vector{<:Real},\n    tf::Real;\n    solve_kwargs\n) -> SciMLBase.ODESolution\n\n\nRun a dynamical simulation of the continuous model.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.disc_dyn-Tuple{ContGridModML.DiscModel, Integer, Real, Real, Real}","page":"Dynamic.jl","title":"ContGridModML.disc_dyn","text":"disc_dyn(\n    dm::ContGridModML.DiscModel,\n    fault_node::Integer,\n    fault_size::Real,\n    dt::Real,\n    tf::Real;\n    solve_kwargs\n) -> SciMLBase.ODESolution\n\n\nRun a dynamical simulation of the discrete model.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.gen_idxs-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel, Real, Integer, Integer}","page":"Dynamic.jl","title":"ContGridModML.gen_idxs","text":"gen_idxs(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel,\n    dP::Real,\n    n_train::Integer,\n    n_test::Integer;\n    seed\n) -> Tuple{Vector{<:Integer}, Vector{<:Integer}}\n\n\nRandomly choose generators from a homoegenous distribution for the training and test sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.generate_comp_idxs-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel, Vector{<:Integer}, Vector{<:Integer}, Int64}","page":"Dynamic.jl","title":"ContGridModML.generate_comp_idxs","text":"generate_comp_idxs(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel,\n    tri::Vector{<:Integer},\n    tei::Vector{<:Integer},\n    n::Int64\n) -> Vector{<:Integer}\n\n\nGenerate a list of indices used for the comparison of the ground truth with the results     from the continuous model.\n\nAn equally spaced grid is overlaid over the area. If the points are within the area, the closest bus in the discrete model is found and added to the list of indices. The generators of the test and training set are not eligible for comparison and are remove from the list of possible indices. The number of points can be controlled by n, which gives the number of points in the largest dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.grad","page":"Dynamic.jl","title":"ContGridModML.grad","text":"grad(\n    sol_cont::SciMLBase.ODESolution,\n    sol_lambda::SciMLBase.ODESolution,\n    g_proj::Vector{SparseArrays.SparseMatrixCSC}\n) -> Vector{Float64}\ngrad(\n    sol_cont::SciMLBase.ODESolution,\n    sol_lambda::SciMLBase.ODESolution,\n    g_proj::Vector{SparseArrays.SparseMatrixCSC},\n    dt::Real\n) -> Vector{Float64}\n\n\nCalculate the gradient from the solution of the adjoint dynamics.\n\n\n\n\n\n","category":"function"},{"location":"api/internal/dynamic/#ContGridModML.grad_proj-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Matrix{<:Real}, Integer}","page":"Dynamic.jl","title":"ContGridModML.grad_proj","text":"grad_proj(\n    A::SparseArrays.SparseMatrixCSC,\n    q_proj::SparseArrays.SparseMatrixCSC,\n    evecs::Matrix{<:Real},\n    n_coeffs::Integer\n) -> Vector{SparseArrays.SparseMatrixCSC}\n\n\nCalculate the projection matrix of the discrete solution onto the adjoint solution.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.init_expansion-Tuple{Matrix{<:Real}, Integer, Integer, Vector{<:Real}, Vector{<:Real}}","page":"Dynamic.jl","title":"ContGridModML.init_expansion","text":"init_expansion(\n    eve::Matrix{<:Real},\n    n_modes::Integer,\n    n_coeffs::Integer,\n    m::Vector{<:Real},\n    d::Vector{<:Real}\n) -> Tuple{Vector{T} where T<:Real, Matrix{<:Real}}\n\n\nCreate the initial values for the parameters.\n\nThe parameters are expanded in eigenvectors of the grid Laplacian. The first n_modes eigenvectors are chosen. The first n_coeffs coefficients are chosen by projecting the results of the heat equation diffusion onto the eigenvectors. The n_modes - n_coeffs are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.initial_conditions-Tuple{ContGridModML.ContModel}","page":"Dynamic.jl","title":"ContGridModML.initial_conditions","text":"initial_conditions(\n    cm::ContGridModML.ContModel\n) -> Vector{T} where T<:Real\n\n\nCreate the initial conditions for the continuous simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.lambda_dyn-Tuple{SciMLBase.ODESolution, SciMLBase.ODESolution, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Real, Vector{<:Integer}}","page":"Dynamic.jl","title":"ContGridModML.lambda_dyn","text":"lambda_dyn(\n    cont_sol::SciMLBase.ODESolution,\n    disc_sol::SciMLBase.ODESolution,\n    M::SparseArrays.SparseMatrixCSC,\n    K::SparseArrays.SparseMatrixCSC,\n    ω_proj::SparseArrays.SparseMatrixCSC,\n    tf::Real,\n    idxs::Vector{<:Integer};\n    solve_kwargs\n) -> SciMLBase.ODESolution\n\n\nSolve the adjoint dynamics.\n\nThe continuous and discrete solutions are needed as well as the comparison indices to calculate the contributions from the loss function.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.lap_eigenvectors-Tuple{ContGridModML.ContModel}","page":"Dynamic.jl","title":"ContGridModML.lap_eigenvectors","text":"lap_eigenvectors(\n    cm::ContGridModML.ContModel\n) -> Matrix{Float64}\n\n\nCalculate the eigenvectors of the unweighted Laplacian of the grid used for the continuous     simulations.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.learn_dynamical_parameters-Tuple{}","page":"Dynamic.jl","title":"ContGridModML.learn_dynamical_parameters","text":"learn_dynamical_parameters(\n;\n    dm_fn,\n    cm_fn,\n    dP,\n    n_train,\n    n_test,\n    dt,\n    tf,\n    disc_solve_kwargs,\n    cont_solve_kwargs,\n    lambda_solve_kwargs,\n    seed,\n    n_points,\n    m_init,\n    d_init,\n    n_coeffs,\n    n_modes,\n    n_epochs,\n    max_function,\n    train_ix,\n    test_ix\n) -> ContGridModML.DynamicSol\n\n\nLearn the inertia and damping distribution for the continuous model.\n\nThe frequency response of faults at multiple generators are compared on homogeneously spread buses across the grid. The gradient is calculated using an adjoint sensitivity method and the updates to the parameters are calculated using a constraint gradient descent method.\n\nArguments\n\ndm_fn::String = MODULE_FOLDER * \"/data/dm.h5\": File name of the discrete model\ncm_fn::String = MODULE_FOLDER * \"/data/cm.h5\": File name of the continuous model\ndP::Real = -9.0: Fault size to be simulated\nn_train::Integer = 12: Amount of faults to consider for training\nn_test::Integer = 4: Amount of faults to consider for testing\ndt::Real = 0.01: Step size at which the solutions of the ODEs are saved\ntf::Real = 25.0: Duration of the simulations\ndisc_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(): Keyword arguments passed  to the ODE solver for the discrete model\ncont_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(): Keyword arguments passed  to the ODE solver for the continuous model\nlambda_solve_kwargs::Dict{Symbol, <:Any} = Dict{Symbol, Any}(:saveat => 0.1,  :abstol => 1e-3, :reltol => 1e-2): Keyword arguments passed to the ODE solver of the  adjoint equations\nseed::Union{Nothing, Integer} = 1709: Seed for the random number generator to be used   to pick the training and test generators\nσ = 0.05: Standard deviation of the Gaussian used to distribute the fault\nn_points = 40: Number of points for comparison along the largest dimension\nn_coeffs = 1: Number of coefficients that are non-zero at the beginning of the  training. They correspond to the n_coeffs lowest modes of the Laplacian.\nn_modes = 20: Number of modes the Laplacian that are used to expand the parameters.\nn_epochs = 8000: Number of epochs used for the training.\nmax_function::Function = (x) -> 30 * 2^(x / 500): Function that changes the magnitude  of the change vector of the parameters wrt the epoch.\ntrain_ix::Union{Nothing, Vector{<:Integer}} = nothing: Indices of the generators used  for training if they are not supposed to be picked randomly.\ntest_ix::Union{Nothing, Vector{<:Integer}} = nothing: Indices of the generators used  for testing if they are not supposed to be picked randomly.\n\nwarning: Warning\nIf the training and test generators are not supposed to be picked randomly, both train_ix and test_ix need to be passed.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.loss-Tuple{SciMLBase.ODESolution, SciMLBase.ODESolution, SparseArrays.SparseMatrixCSC, Vector{<:Integer}}","page":"Dynamic.jl","title":"ContGridModML.loss","text":"loss(\n    sol_cont::SciMLBase.ODESolution,\n    sol_disc::SciMLBase.ODESolution,\n    ω_proj::SparseArrays.SparseMatrixCSC,\n    idxs::Vector{<:Integer}\n) -> Vector{Float64}\n\n\nCalculate the value of the loss function.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.projectors_dynamic-Tuple{ContGridModML.ContModel, ContGridModML.DiscModel, Vector{<:Integer}}","page":"Dynamic.jl","title":"ContGridModML.projectors_dynamic","text":"projectors_dynamic(\n    cm::ContGridModML.ContModel,\n    dm::ContGridModML.DiscModel,\n    ω_idxs::Vector{<:Integer}\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCreate projectors for nodal values onto quadrature points and onto comparison locations.\n\nReturned projectors\n\nω_proj Project the nodal values onto the given comparison points. This is used to   calculate the loss function.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.simul-Union{Tuple{T}, Tuple{SciMLBase.ODESolution, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{T}, Vector{T}, Vector{T}, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{SparseArrays.SparseMatrixCSC}, Vector{<:Integer}, Vector{T}, Real}} where T<:Real","page":"Dynamic.jl","title":"ContGridModML.simul","text":"simul(\n    disc_sol::SciMLBase.ODESolution,\n    M_const::SparseArrays.SparseMatrixCSC,\n    K_const::SparseArrays.SparseMatrixCSC,\n    m::Array{T<:Real, 1},\n    d::Array{T<:Real, 1},\n    f::Array{T<:Real, 1},\n    A::SparseArrays.SparseMatrixCSC,\n    q_proj::SparseArrays.SparseMatrixCSC,\n    ω_proj::SparseArrays.SparseMatrixCSC,\n    g_proj::Vector{SparseArrays.SparseMatrixCSC},\n    idxs::Vector{<:Integer},\n    u₀::Array{T<:Real, 1},\n    tf::Real;\n    cont_kwargs,\n    lambda_kwargs\n) -> Tuple{Vector{T} where T<:Real, Real}\n\n\nDo a full simulation step for one data set.\n\nThe continuous solution is calculated first and then used to obtain the adjoint solution. Afterwards, the gradient and value of the loss function are calculated and returned.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.test_loss-Tuple{Vector{SciMLBase.ODESolution}, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{<:Real}, Vector{<:Real}, Matrix{<:Real}, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC, Vector{<:Integer}, Vector{<:Real}, Real}","page":"Dynamic.jl","title":"ContGridModML.test_loss","text":"test_loss(\n    disc_sols::Vector{SciMLBase.ODESolution},\n    M_const::SparseArrays.SparseMatrixCSC,\n    K_const::SparseArrays.SparseMatrixCSC,\n    m::Vector{<:Real},\n    d::Vector{<:Real},\n    f_test::Matrix{<:Real},\n    A::SparseArrays.SparseMatrixCSC,\n    q_proj::SparseArrays.SparseMatrixCSC,\n    ω_proj::SparseArrays.SparseMatrixCSC,\n    idxs::Vector{<:Integer},\n    u₀::Vector{<:Real},\n    tf::Real;\n    cont_kwargs\n) -> Vector{Float64}\n\n\nCalculate the loss values for the test data sets.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.trapz-Tuple{Real, Real, Real, Function, Integer}","page":"Dynamic.jl","title":"ContGridModML.trapz","text":"trapz(\n    t₀::Real,\n    tf::Real,\n    dt::Real,\n    int!::Function,\n    N::Integer\n) -> Vector{Float64}\n\n\nTrapezoidal rule for the integration of a given function.\n\n\n\n\n\n","category":"method"},{"location":"api/internal/dynamic/#ContGridModML.update-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Matrix{T}, Integer, Function}} where T<:Real","page":"Dynamic.jl","title":"ContGridModML.update","text":"update(\n    p::Array{T<:Real, 1},\n    g::Array{T<:Real, 1},\n    eve::Array{T<:Real, 2},\n    i::Integer,\n    f::Function\n) -> Vector{T} where T<:Real\n\n\nUpdate the parameters using a restricted gradient descent to ensure positiveness.\n\n\n\n\n\n","category":"method"},{"location":"#Machine-Learning-Package-for-ContGridMod","page":"Introduction","title":"Machine Learning Package for ContGridMod","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementation of physics-informed machine learning routines for the continuous power grid model package ContGridMod.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ContGridModML can easily be installed using the Julia package manager.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/laurentpagnier/ContGridMod.jl#FiniteElements\")\njulia> Pkg.add(url=\"https://github.com/julianfritzsch/ContGridModML.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis package needs the FiniteElements branch of ContGridMod. This might conflict with preinstalled versions of ContGridMod. If there are any problems using this package, remove any versions of ContGridMod checked out for development and try again.","category":"page"},{"location":"#Quickstart-Guide","page":"Introduction","title":"Quickstart Guide","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To reproduce the results you only need to run two functions. The static parameters, i.e., the susceptances in x and y direction (b_x(mathbfr) and b_y(mathbfr)), can be learned by running","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> sol = learn_susceptances()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similarly, to learn the dynamical parameters, i.e., the inertia m(mathbfr) and the damping d(mathbfr), run","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> sol = learn_dynamical_parameters()","category":"page"}]
}
